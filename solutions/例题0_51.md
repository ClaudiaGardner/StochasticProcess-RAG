# 例题0.51

## 题目

设两个多项式f(x)，g(x)，编写一段程序计算乘积h(x) = f(x)g(x)。给出一种测试所写程序 正确与否的方法。

## 解答

**Considering Problem Details**

\n\n

I've clarified the solution approach. My focus now is on translating the algorithmic steps into LaTeX. I'll define polynomials, outline the convolution formula, and formalize the verification test using random evaluation, ensuring that the final output aligns perfectly with the prescribed format. I'm prioritizing clarity in mathematical notation.


### 题目分析

本题考查多项式的代数运算与随机算法（Randomized Algorithms）中的**多项式恒等测试（Polynomial Identity Testing）**。
题目包含两个部分：
1.  **计算**：实现多项式乘法，即求卷积。对于两个多项式 $f(x)$ 和 $g(x)$，其乘积 $h(x)$ 的系数由 $f$ 和 $g$ 系数的卷积给出。
2.  **验证**：设计一种方法测试结果的正确性。在概率论与随机过程的背景下，这通常指向利用随机化方法（蒙特卡洛方法）进行高效验证，而非重新计算一遍。核心原理基于代数基本定理：非零多项式的根的数量有限。

### 解题过程

#### 1. 多项式乘法程序的算法逻辑

设多项式 $f(x)$ 和 $g(x)$ 分别为：
$$f(x) = \sum_{i=0}^{n} a_i x^i, \quad g(x) = \sum_{j=0}^{m} b_j x^j$$
其中 $n$ 和 $m$ 分别为 $f(x)$ 和 $g(x)$ 的次数。

它们的乘积 $h(x) = f(x)g(x)$ 是一个次数为 $n+m$ 的多项式：
$$h(x) = \sum_{k=0}^{n+m} c_k x^k$$

其中，系数 $c_k$ 由卷积公式给出：
$$c_k = \sum_{i=0}^{k} a_i b_{k-i}$$
注意：在此求和中，若下标超出定义域（即 $i > n$ 或 $k-i > m$），则对应的 $a_i$ 或 $b_{k-i}$ 取为 $0$。

**程序逻辑（伪代码）：**
1.  初始化数组 $C$ 长度为 $n+m+1$，所有元素置为 $0$。
2.  对于 $i$ 从 $0$ 到 $n$：
    对于 $j$ 从 $0$ 到 $m$：
    $$C[i+j] \leftarrow C[i+j] + a_i \cdot b_j$$
3.  返回数组 $C$ 作为 $h(x)$ 的系数。

#### 2. 测试程序正确性的方法（随机化验证）

为了验证计算出的多项式 $h(x)$ 是否确实等于 $f(x)g(x)$，我们不应再次执行复杂的乘法运算（时间复杂度 $O(nm)$ 或 $O((n+m)\log(n+m))$），而应采用**随机化恒等测试**，其时间复杂度仅为 $O(n+m)$。

**理论基础：**
定义差值多项式 $D(x) = h(x) - f(x)g(x)$。
- 如果程序正确，则 $h(x) \equiv f(x)g(x)$，即 $D(x)$ 是零多项式，对任意 $x$ 都有 $D(x) = 0$。
- 如果程序错误，则 $D(x)$ 是一个非零多项式，其次数不超过 $n+m$。根据代数基本定理，一个次数为 $d$ 的非零多项式最多有 $d$ 个根。

**测试步骤：**
1.  从一个足够大的数域或整数集合 $S$ 中，**均匀随机**选取一个数值 $r$。为了保证错误率极低，集合的大小 $|S|$ 应远大于多项式的度数 $n+m$。
2.  分别计算 $v_1 = f(r)$， $v_2 = g(r)$ 和 $v_3 = h(r)$。计算多项式在某一点的值通常使用**秦九韶算法（Horner's Method）**，时间复杂度为 $O(n)$。
3.  检查是否满足 $v_3 = v_1 \cdot v_2$。
    - 若 $v_3 \neq v_1 \cdot v_2$，则程序**一定**有误。
    - 若 $v_3 = v_1 \cdot v_2$，则程序**以极高概率**正确。

**错误概率分析：**
假设程序计算错误（即 $D(x) \not\equiv 0$），测试通过（即 $D(r)=0$）的概率为：
$$P(\text{Error not detected}) = P(D(r) = 0) \le \frac{\deg(D)}{|S|} \le \frac{n+m}{|S|}$$
只要选取足够大的 $|S|$（例如 $|S| \ge 100(n+m)$），错误概率将小于 $1\%$。通过多次独立重复测试，错误概率可呈指数级下降。

### 答案

**1. 乘积计算公式：**
$$h(x) = \sum_{k=0}^{n+m} \left( \sum_{i=0}^{k} a_i b_{k-i} \right) x^k$$

**2. 测试方法：**
采用**随机化恒等测试**。
从大集合 $S$ 中随机选取 $r$，计算并验证：
$$h(r) \stackrel{?}{=} f(r) \cdot g(r)$$
若等式不成立，则程序错误；若等式成立，则程序以概率 $1 - \frac{n+m}{|S|}$ 正确。

### 知识延伸

1.  **Schwartz-Zippel 引理**：本题的测试方法是 Schwartz-Zippel 引理在单变量多项式中的特例。该引理是随机化算法领域的基石，用于判断多元多项式是否恒为零。
2.  **蒙特卡洛算法（Monte Carlo Algorithm）**：这是一种具有**单边错误（One-sided Error）**的随机算法。
    - 如果程序实际上是错的，算法有可能（以小概率）误报为“正确”。
    - 如果程序实际上是对的，算法永远报告“正确”。
3.  **计算复杂度优势**：
    - 朴素多项式乘法复杂度：$O(n^2)$。
    - 快速傅里叶变换（FFT）乘法复杂度：$O(n \log n)$。
    - 随机化验证复杂度：$O(n)$。
    验证比求解快得多，这是随机化验证在工程和理论中的核心价值（例如 Freivalds 算法用于验证矩阵乘法）。
4.  **易错点**：在实际编程实现测试时，若 $f(r)g(r)$ 数值过大导致溢出，通常需要在模大素数域（Finite Field $\mathbb{F}_p$）下进行运算。

---
